---------- in ./sysdeps/x86_64/nptl/tls.h
```
#  define THREAD_SELF \
  (*(struct pthread *__seg_fs *) offsetof (struct pthread, header.self))
# else
#  define THREAD_SELF \
  ({ struct pthread *__self;						      \
     asm ("mov %%fs:%c1,%0" : "=r" (__self)				      \
	  : "i" (offsetof (struct pthread, header.self)));	 	      \
     __self;})
# endif

```
---------- in nptl/pthread_self.c
```
#include "pthreadP.h"
#include <tls.h>

pthread_t
__pthread_self (void)
{
  return (pthread_t) THREAD_SELF;
}
libc_hidden_def (__pthread_self)
weak_alias (__pthread_self, pthread_self)

```
userland thread-id   -> returned by pthread_self()
kernelland thread-ed -> returned by gettid()

-----------------------------------
#clone()
       CLONE_THREAD (since Linux 2.4.0)
              If  CLONE_THREAD  is  set,  the  child  is  placed  in the same thread group as the calling process.  To make the remainder of the discussion of CLONE_THREAD more readable, the term
              "thread" is used to refer to the processes within a thread group.

              Thread groups were a feature added in Linux 2.4 to support the POSIX threads notion of a set of threads that share a single PID.  Internally, this shared PID is the so-called thread
              group identifier (TGID) for the thread group.  Since Linux 2.4, calls to getpid(2) return the TGID of the caller.

              The threads within a group can be distinguished by their (system-wide) unique thread IDs (TID).  A new thread's TID is available as the function result returned to the caller, and a
              thread can obtain its own TID using gettid(2).

              When a clone call is made without specifying CLONE_THREAD, then the resulting thread is placed in a new thread group whose TGID is the same as the thread's TID.  This thread is  the
              leader of the new thread group.

              A  new  thread  created  with CLONE_THREAD has the same parent process as the process that made the clone call (i.e., like CLONE_PARENT), so that calls to getppid(2) return the same
              value for all of the threads in a thread group.  When a CLONE_THREAD thread terminates, the thread that created it is not sent a SIGCHLD (or other termination) signal; nor  can  the
              status of such a thread be obtained using wait(2).  (The thread is said to be detached.)

              After all of the threads in a thread group terminate the parent process of the thread group is sent a SIGCHLD (or other termination) signal.

              If  any  of  the  threads  in a thread group performs an execve(2), then all threads other than the thread group leader are terminated, and the new program is executed in the thread
              group leader.

              If one of the threads in a thread group creates a child using fork(2), then any thread in the group can wait(2) for that child.

              Since Linux 2.5.35, the flags mask must also include CLONE_SIGHAND if CLONE_THREAD is specified (and note that, since Linux 2.6.0, CLONE_SIGHAND also requires  CLONE_VM  to  be  in‐
              cluded).

              Signal  dispositions and actions are process-wide: if an unhandled signal is delivered to a thread, then it will affect (terminate, stop, continue, be ignored in) all members of the
              thread group.

              Each thread has its own signal mask, as set by sigprocmask(2).

              A signal may be process-directed or thread-directed.  A process-directed signal is targeted at a thread group (i.e., a TGID), and is delivered to an arbitrarily selected thread from
              among those that are not blocking the signal.  A signal may be process-directed because it was generated by the kernel for reasons other than a hardware exception, or because it was
              sent using kill(2) or sigqueue(3).  A thread-directed signal is targeted at (i.e., delivered to) a specific thread.  A signal may be  thread  directed  because  it  was  sent  using
              tgkill(2)  or  pthread_sigqueue(3), or because the thread executed a machine language instruction that triggered a hardware exception (e.g., invalid memory access triggering SIGSEGV
              or a floating-point exception triggering SIGFPE).

              A call to sigpending(2) returns a signal set that is the union of the pending process-directed signals and the signals that are pending for the calling thread.

              If a process-directed signal is delivered to a thread group, and the thread group has installed a handler for the signal, then the handler is invoked in exactly one, arbitrarily se‐
              lected  member of the thread group that has not blocked the signal.  If multiple threads in a group are waiting to accept the same signal using sigwaitinfo(2), the kernel will arbi‐
              trarily select one of these threads to receive the signal.

----------------------------
#gettid()

NOTES
       The thread ID returned by this call is not the same thing as a POSIX thread ID (i.e., the opaque value returned by pthread_self(3)).

       In a new thread group created by a clone(2) call that does not specify the CLONE_THREAD flag (or, equivalently, a new process created by fork(2)), the new process is a thread group leader,
       and its thread group ID (the value returned by getpid(2)) is the same as its thread ID (the value returned by gettid()).

